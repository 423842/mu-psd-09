<template>
  <div id="app">
    <h1>éŸ³å£°æ„Ÿæƒ…åˆ†æã‚¢ãƒ—ãƒª</h1>
    <p>éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã€ãƒã‚¤ã‚¯ã§éŒ²éŸ³ã—ã¦æ„Ÿæƒ…ã‚’åˆ¤å®šã—ã¾ã™ã€‚</p>

    <div class="tabs">
      <button 
        :class="{ active: selectedTab === 'file' }" 
        @click="selectTab('file')">
        WAVãƒ•ã‚¡ã‚¤ãƒ«
      </button>
      <button 
        :class="{ active: selectedTab === 'record' }" 
        @click="selectTab('record')">
        éŸ³å£°ã‚’éŒ²éŸ³
      </button>
    </div>

    <div v-if="selectedTab === 'file'" class="tab-content">
      <input type="file" @change="handleFileUpload" v-if="!loading" />
      <button @click="uploadFile" :disabled="!selectedFile || loading" class="action-button" :style="{ minWidth: '180px' }">
        {{ loading ? `è§£æä¸­${'.'.repeat(loadingDotsCount)}` : 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦è§£æ' }}
      </button>
    </div>

    <div v-if="selectedTab === 'record'" class="tab-content">
      <div class="record-controls">
        <button 
          @click="initiateRecording" 
          :disabled="recording || loading || countdown > 0" 
          class="record-button">
          éŒ²éŸ³é–‹å§‹
        </button>
        <button 
          @click="stopRecording" 
          :disabled="!recording" 
          class="stop-button">
          éŒ²éŸ³åœæ­¢
        </button>
      </div>
      <p v-if="countdown > 0" class="countdown-indicator recording-indicator">{{ countdown }}ç§’å¾Œã«é–‹å§‹...</p>
      <p v-if="recording" class="recording-indicator">ğŸ”´ éŒ²éŸ³ä¸­...</p>
      <div v-if="recording" class="progress-bar-container">
        <div class="progress-bar" :style="{ width: remainingTime + '%' }"></div>
      </div>
      
      <button 
        v-if="recordedFile && !loading && countdown <= 0" 
        @click="uploadRecordedAudio" 
        class="action-button analyze-button">
        è§£æ
      </button>
      <p v-if="recordedFile && !loading && countdown <= 0" class="recorded-info">éŒ²éŸ³å®Œäº†ï¼ã€Œè§£æã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
      <p v-if="loading" class="loading-indicator">è§£æä¸­{{ '.'.repeat(loadingDotsCount) }}</p>
    </div>
    
    <div v-if="result">
      <h2 v-if="selectedTab === 'file'">{{ selectedFile.name }}ã®è§£æçµæœ</h2>
      <h2 v-if="selectedTab === 'record'">éŒ²éŸ³ã—ãŸéŸ³å£°ã®è§£æçµæœ</h2>
      <p><strong>ãƒ†ã‚­ã‚¹ãƒˆ:</strong> {{ result.transcription }}</p>
      <h3 v-if="dominantEmotion" class="summary-text">
        ã“ã®éŸ³å£°ã«ã¯ 
        <strong :style="{ color: getOpaqueColor(emotionColors[dominantEmotion.label]) }">
          {{ dominantEmotion.label }}
        </strong>
        ã®æ„Ÿæƒ…ãŒ <strong>{{ dominantEmotion.score }}%</strong> å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
      </h3>
      
      <h3>æ„Ÿæƒ…ã‚¹ã‚³ã‚¢</h3>
      <ul>
        <li
          v-for="emotion in result.emotions"
          :key="emotion.label"
          :style="{ 
            '--score-width': emotion.score + '%', 
            '--score-color': emotionColors[emotion.label] 
          }"
        >
          <div class="score-bar"></div>
          <strong>{{ emotion.label }}:</strong> {{ emotion.score }}%
        </li>
      </ul>
    </div>
  </div>
</template>

<script>
import axios from "axios";

export default {
  name: "App",
  data() {
    return {
      selectedTab: 'file', // 'file' or 'record'
      selectedFile: null,
      result: null,
      loading: false,
      recording: false,
      recordedFile: null,
      mediaRecorder: null,
      audioChunks: [],
      ffmpeg: null,
      loadingDotsCount: 0,
      loadingInterval: null,
      remainingTime: 100, // æ®‹ã‚Šæ™‚é–“ã®ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸
      recordingTimer: null, // éŒ²éŸ³ã‚¿ã‚¤ãƒãƒ¼
      countdown: 0, // éŒ²éŸ³é–‹å§‹ã¾ã§ã®ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³
      emotionColors: { // æ„Ÿæƒ…ã¨è‰²ã®ãƒãƒƒãƒ”ãƒ³ã‚°
        'å–œã³': 'rgba(255, 225, 0, 0.4)',
        'æ‚²ã—ã¿': 'rgba(0, 130, 255, 0.3)',
        'æ€’ã‚Š': 'rgba(255, 0, 0, 0.3)',
        'é©šã': 'rgba(255, 135, 0, 0.3)',
        'ææ€–': 'rgba(128, 0, 128, 0.3)',
        'å«Œæ‚ª': 'rgba(0, 128, 0, 0.3)',
        'ä¸­ç«‹': 'rgba(220, 220, 220, 0.4)',
        'ãã®ä»–': 'rgba(80, 80, 80, 0.3)'
      }
    };
  },
  async mounted() {
    if (window.FFmpeg) {
      this.ffmpeg = window.FFmpeg.createFFmpeg({ log: true });
      await this.ffmpeg.load();
      console.log("ffmpeg.wasm is loaded.");
    }
  },
  watch: {
    loading(isLoading) {
      if (isLoading) {
        // Start the dot animation
        this.loadingInterval = setInterval(() => {
          this.loadingDotsCount = (this.loadingDotsCount + 1) % 4; // 0, 1, 2, 3
        }, 1000); // 1ç§’ã”ã¨ã«æ›´æ–°
      } else {
        // Stop the dot animation
        clearInterval(this.loadingInterval);
        this.loadingInterval = null;
        this.loadingDotsCount = 0; // Reset dots
      }
    },
    dominantEmotion(newEmotion, oldEmotion) {
      if (newEmotion) {
        const baseColor = this.emotionColors[newEmotion.label];
        if (baseColor) {
          // 'rgba(r,g,b,a)' -> 'rgba(r,g,b,0.1)'
          const parts = baseColor.match(/[\d.]+/g);
          if (parts && parts.length >= 3) {
            document.body.style.backgroundColor = `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, 0.1)`;
          }
        }
      } else if (oldEmotion) {
        // Reset background color when result is cleared
        document.body.style.backgroundColor = '';
      }
    }
  },
  computed: {
    dominantEmotion() {
      if (!this.result || !this.result.emotions || this.result.emotions.length === 0) {
        return null;
      }
      // Use reduce to find the emotion with the highest score
      return this.result.emotions.reduce((max, current) => {
        // The score from the API is a string like "98.86", so we need to parse it to a number.
        const maxScore = parseFloat(max.score);
        const currentScore = parseFloat(current.score);
        return currentScore > maxScore ? current : max;
      });
    }
  },
  methods: {
    selectTab(tab) {
      this.selectedTab = tab;
      // Clear the analysis result and recorded file when switching tabs
      this.result = null;
      this.recordedFile = null;
      this.selectedFile = null;
    },
    getOpaqueColor(rgbaColor) {
      if (!rgbaColor) return '#2c3e50'; // Default color
      // 'rgba(r,g,b,a)' -> 'rgb(r,g,b)'
      // This makes the color fully opaque for text.
      const parts = rgbaColor.match(/[\d.]+/g);
      if (!parts || parts.length < 3) return '#2c3e50';
      return `rgb(${parts[0]}, ${parts[1]}, ${parts[2]})`;
    },
    handleFileUpload(event) {
      this.selectedFile = event.target.files[0];
      this.recordedFile = null;
    },
    async uploadFile() {
      if (!this.selectedFile) return;
      this.loading = true;
      this.result = null;

      const formData = new FormData();
      formData.append("file", this.selectedFile);

      try {
        const response = await axios.post("/api/upload", formData, {
          headers: {
            "Content-Type": "multipart/form-data",
          },
        });
        this.result = response.data;
      } catch (error) {
        console.error("ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—:", error);
      } finally {
        this.loading = false;
      }
    },
    initiateRecording() {
      this.countdown = 3;
      const countdownInterval = setInterval(() => {
        this.countdown -= 1;
        if (this.countdown <= 0) {
          clearInterval(countdownInterval);
          // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€å®Ÿéš›ã®éŒ²éŸ³å‡¦ç†ã‚’é–‹å§‹
          // recordingãƒ•ãƒ©ã‚°ãŒfalseã®å ´åˆã®ã¿å®Ÿè¡Œï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¿ãƒ–ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ãªã©ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã‚’è€ƒæ…®ï¼‰
          if (!this.recording) {
            this.startRecording();
          }
        }
      }, 1000);
    },
    async startRecording() {
      this.result = null;
      this.recordedFile = null;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        this.audioChunks = [];
        this.mediaRecorder.ondataavailable = event => {
          this.audioChunks.push(event.data);
        };
        this.mediaRecorder.onstop = () => {
          const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
          this.recordedFile = new File([audioBlob], 'recorded_audio.webm', { type: 'audio/webm' });
          stream.getTracks().forEach(track => track.stop());
        };
        this.mediaRecorder.start();
        this.recording = true;
        this.remainingTime = 100; // ãƒãƒ¼ã‚’100%ã«ãƒªã‚»ãƒƒãƒˆ

        // 100msã”ã¨ã«ãƒãƒ¼ã‚’æ›´æ–°
        this.recordingTimer = setInterval(() => {
          this.remainingTime -= 1; // 100ms * 100å› = 10ç§’
          if (this.remainingTime <= 0) {
            clearInterval(this.recordingTimer);
          }
        }, 100);

        // 10ç§’å¾Œã«éŒ²éŸ³ã‚’è‡ªå‹•åœæ­¢
        setTimeout(() => {
          // mediaRecorderãŒå­˜åœ¨ã—ã€éŒ²éŸ³ä¸­ã®å ´åˆã®ã¿åœæ­¢ã™ã‚‹
          if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.stopRecording();
          }
        }, 10000);
      } catch (err) {
        console.error("ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", err);
        alert("ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™ã€‚");
      }
    },
    stopRecording() {      if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
        this.mediaRecorder.stop();
        this.recording = false;
      }
    },
    async uploadRecordedAudio() {
      if (!this.recordedFile) return;
      if (!this.ffmpeg) {
        console.error("FFmpeg.wasm is not loaded yet.");
        return;
      }

      this.loading = true;
      this.result = null;

      try {
        // Step 1: Write the recorded file to FFmpeg's file system
        const fetchFile = window.FFmpeg.fetchFile;
        this.ffmpeg.FS('writeFile', 'input.webm', await fetchFile(this.recordedFile));

        // Step 2: Convert WebM to WAV
        await this.ffmpeg.run('-i', 'input.webm', '-acodec', 'pcm_s16le', '-ac', '1', '-ar', '16000', 'output.wav');

        // Step 3: Read the converted WAV file
        const data = this.ffmpeg.FS('readFile', 'output.wav');
        const convertedWav = new Blob([data.buffer], { type: 'audio/wav' });

        // Step 4: Send the converted WAV file to the backend
        const formData = new FormData();
        formData.append("file", convertedWav, "converted.wav");

        const response = await axios.post("/api/upload", formData, {
          headers: {
            "Content-Type": "multipart/form-data",
          },
        });
        this.result = response.data;
      } catch (error) {
        console.error("ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—:", error);
      } finally {
        this.loading = false;
      }
    }
  },
};
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}

/* Tabs */
.tabs {
  display: flex;
  justify-content: center;
  margin-bottom: 20px;
}

.tabs button {
  background-color: #f0f0f0;
  color: #555;
  border: 1px solid #ccc;
  padding: 10px 20px;
  border-radius: 5px 5px 0 0;
  cursor: pointer;
  font-size: 16px;
  margin: 0 2px;
  transition: all 0.3s ease;
}

.tabs button:hover {
  background-color: #e0f7ff; /* è–„ã„ç©ºè‰² */
}

.tabs button.active {
  background-color: #007bff; /* æ¿ƒã„é’è‰² */
  color: white;
  border-bottom: 1px solid white;
}

.tab-content {
  border: 1px solid #ccc;
  border-radius: 0 5px 5px 5px;
  padding: 20px;
  max-width: 500px;
  margin: 0 auto;
}

/* Common button styles */
.action-button {
  background-color: #4CAF50;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  margin-top: 10px;
  margin-left: 5px;
  margin-right: 5px;
}

.action-button:hover:not(:disabled) {
  background-color: #45a049;
}

.action-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: #cccccc;
  color: #666666;
}

/* Record specific styles */
.record-controls {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
}

.record-controls button {
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  margin-top: 10px;
  transition: background-color 0.3s ease;
}

.record-button { background-color: #e74c3c; } /* Red */
.record-button:hover:not(:disabled) { background-color: #e96358; } /* Lighter Red */
.record-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.stop-button { background-color: #f39c12; }  /* Orange */
.stop-button:hover:not(:disabled) { background-color: #f5a83a; } /* Lighter Orange */
.stop-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.analyze-button { background-color: #4CAF50; } /* Green */
.analyze-button:hover:not(:disabled) { background-color: #45a049; } /* Lighter Green */

.recording-indicator {
  margin-top: 10px;
  color: #e74c3c;
  font-weight: bold;
}

.countdown-indicator {
  margin-top: 10px;
  color: #e74c3c; /* èµ¤è‰²ã«å¤‰æ›´ */
  font-weight: bold;
}

.progress-bar-container {
  width: 80%;
  height: 10px;
  background-color: #e0e0e0;
  border-radius: 5px;
  margin: 10px auto;
}

.progress-bar {
  height: 100%;
  background-color: #e74c3c; /* èµ¤è‰² */
  border-radius: 5px;
  transition: width 0.1s linear; /* ã‚¹ãƒ ãƒ¼ã‚ºãªå¤‰åŒ– */
}

.recorded-info {
  margin-top: 10px;
}

.loading-indicator {
  margin-top: 10px;
  font-weight: bold;
  color: #555;
}

/* Emotion list styles */
ul {
  list-style-type: none;
  padding: 0;
  max-width: 400px;
  margin: 20px auto;
  text-align: left;
}

li {
  position: relative;
  background-color: #f9f9f9;
  border: 1px solid #ddd;
  padding: 10px;
  margin-bottom: 5px;
  border-radius: 5px;
  overflow: hidden;
  z-index: 1;
}

.score-bar {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: var(--score-width);
  background-color: var(--score-color);
  z-index: -1;
  transition: width 0.5s ease-in-out;
}

li strong {
  z-index: 2;
}
</style>
